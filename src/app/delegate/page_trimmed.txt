'use client';
//DELEGATE PAGE
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { useState, useEffect } from 'react';
import {
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  Keypair
} from '@solana/web3.js';
import BN from 'bn.js';
import {
  TOKEN_PROGRAM_ID,
  AccountLayout,
  createInitializeAccountInstruction,
  createTransferInstruction,
  createAssociatedTokenAccountInstruction,
  getAssociatedTokenAddress,
  ASSOCIATED_TOKEN_PROGRAM_ID
} from '@solana/spl-token';

import { TOKEN_X_MINT, TOKEN_Y_MINT, ESCROW_PROGRAM_ID } from '../../utils/constants';
import { notify } from '../components/ui/notify';
import { useGetTokenAccounts, useTokenBalance } from '@/hooks/use-token-accounts';
import { getEscrowAccount, Escrow, ESCROW_ACCOUNT_DATA_LAYOUT } from '@/utils/escrow';

export default function EscrowView() {
  const { connection } = useConnection();
  const { publicKey, signTransaction } = useWallet();
  
  // State for the user’s input amount (Y tokens to deposit)
  const [swapAmount, setSwapAmount] = useState<string>("");

  // Get token accounts for the connected wallet.
  const { data: tokenAccounts, isLoading: isLoadingAccounts } = useGetTokenAccounts({
    address: publicKey,
  });

  // Find the user's token accounts.
  // For initializing the escrow, we need the user's Y token account.
  const tokenXAccount = tokenAccounts?.find(
    (account) => account.account.data.parsed.info.mint === TOKEN_X_MINT.toString()
  );
  const tokenYAccount = tokenAccounts?.find(
    (account) => account.account.data.parsed.info.mint === TOKEN_Y_MINT.toString()
  );

  // Get token balances.
  const { data: balanceX } = useTokenBalance({
    tokenAccount: tokenXAccount ? new PublicKey(tokenXAccount.pubkey) : null,
  });
  const { data: balanceY } = useTokenBalance({
    tokenAccount: tokenYAccount ? new PublicKey(tokenYAccount.pubkey) : null,
  });

  // --------------------------------------------------------------------------
  // New: Initialize Escrow Logic – using the initializer's Y tokens
  // --------------------------------------------------------------------------
  const handleInitializeEscrow = async () => {
    if (!publicKey || !signTransaction || !tokenYAccount) {
      notify({ 
        type: 'error', 
        message: 'Please connect your wallet and ensure you have a JUP token account' 
      });
      return;
    }
  
    const DECIMALS = 9;
    const jupAmount = parseFloat(swapAmount);
    if (isNaN(jupAmount) || jupAmount <= 0) {
      notify({ type: 'error', message: 'Invalid swap amount' });
      return;
    }
  
    const rawAmount = Math.floor(jupAmount * Math.pow(10, DECIMALS));
  
    try {
      const tempTokenAccountKeypair = Keypair.generate();
      const escrowAccountKeypair = Keypair.generate();
  
      // Calculate rent exemptions
      const rentExemptionTempToken = await connection.getMinimumBalanceForRentExemption(
        AccountLayout.span
      );
      const rentExemptionEscrow = await connection.getMinimumBalanceForRentExemption(
        ESCROW_ACCOUNT_DATA_LAYOUT.span
      );
  
      // Get or create GOV token account
      const associatedTokenAddress = await getAssociatedTokenAddress(
        TOKEN_X_MINT,
        publicKey,
        false,
        TOKEN_PROGRAM_ID,
        ASSOCIATED_TOKEN_PROGRAM_ID
      );
  
      console.log('Derived ATA:', associatedTokenAddress.toString());
      console.log('Owner:', publicKey.toString());
      console.log('Mint:', TOKEN_X_MINT.toString());
  
      // Create instructions array
      const instructions = [];
  
      // If GOV token account doesn't exist, add creation instruction
      if (!tokenXAccount) {
        instructions.push(
          createAssociatedTokenAccountInstruction(
            publicKey,                // payer
            associatedTokenAddress,   // ata
            publicKey,                // owner
            TOKEN_X_MINT             // mint
          )
        );
      }
  
      // Add other instructions
      instructions.push(
        // Create temp token account
        SystemProgram.createAccount({
          fromPubkey: publicKey,
          newAccountPubkey: tempTokenAccountKeypair.publicKey,
          lamports: rentExemptionTempToken,
          space: AccountLayout.span,
          programId: TOKEN_PROGRAM_ID,
        }),
        
        // Initialize temp account
        createInitializeAccountInstruction(
          tempTokenAccountKeypair.publicKey,
          TOKEN_Y_MINT,
          publicKey,
          TOKEN_PROGRAM_ID
        ),
  
        // Transfer JUP tokens
        createTransferInstruction(
          new PublicKey(tokenYAccount.pubkey),
          tempTokenAccountKeypair.publicKey,
          publicKey,
          rawAmount,
          [],
          TOKEN_PROGRAM_ID
        ),
  
        // Create escrow account
        SystemProgram.createAccount({
          fromPubkey: publicKey,
          newAccountPubkey: escrowAccountKeypair.publicKey,
          lamports: rentExemptionEscrow,
          space: ESCROW_ACCOUNT_DATA_LAYOUT.span,
          programId: ESCROW_PROGRAM_ID,
        }),
  
        // Initialize escrow
        new TransactionInstruction({
          programId: ESCROW_PROGRAM_ID,
          keys: [
            { pubkey: publicKey, isSigner: true, isWritable: false },
            { pubkey: tempTokenAccountKeypair.publicKey, isSigner: false, isWritable: true },
            { pubkey: associatedTokenAddress, isSigner: false, isWritable: false },
            { pubkey: escrowAccountKeypair.publicKey, isSigner: false, isWritable: true },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
          ],
          data: Buffer.from(
            Uint8Array.of(0, ...new BN(rawAmount).toArray("le", 8))
          ),
        })
      );
  
      const transaction = new Transaction();
      instructions.forEach(ix => transaction.add(ix));
      
      transaction.feePayer = publicKey;
      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
      transaction.partialSign(tempTokenAccountKeypair, escrowAccountKeypair);
  
      const signedTx = await signTransaction(transaction);
      notify({ type: 'info', message: 'Please confirm the escrow initialization...' });
      
      const txId = await connection.sendRawTransaction(signedTx.serialize(), {
        skipPreflight: false,
        preflightCommitment: "confirmed"
      });
      
      notify({ type: 'info', message: 'Setting up your escrow...' });
      
      // Add better error handling for transaction confirmation
      const confirmation = await connection.confirmTransaction(txId, 'confirmed');
      if (confirmation.value.err) {
        const err = confirmation.value.err;
        throw new Error(`Transaction failed: ${JSON.stringify(err)}`);
      }
  
      notify({ 
        type: 'success', 
        message: `Escrow initialized! Offering ${jupAmount} JUP for ${jupAmount} GOV` 
      });
  
      await fetchEscrow();
    } catch (error: any) {
      console.error('Initialize Escrow error:', error);
      // Check if it's a SendTransactionError
      if (error.logs) {
        console.error('Transaction logs:', error.logs);
      }
      notify({ type: 'error', message: `Failed to initialize escrow: ${error.message}` });
    }
  };

  // --------------------------------------------------------------------------
  // Fetch Escrow Data
  // --------------------------------------------------------------------------
  const fetchEscrow = async () => {
    try {
      setIsLoading(true);
      const fetchedEscrow = await getEscrowAccount(connection);
      console.log('Fetched escrow:', fetchedEscrow);
      setEscrow(fetchedEscrow);
    } catch (error) {
      console.error('Error fetching escrow:', error);
      notify({ type: 'error', message: 'Failed to fetch escrow' });
    } finally {
      setIsLoading(false);
    }
  };

  // --------------------------------------------------------------------------
  // UI
  // --------------------------------------------------------------------------
  return (
    <div className="container mx-auto p-8">
      <div className="grid gap-4">
        {/* Token Balances */}
        <div className="grid grid-cols-2 gap-4 mb-4">
          <div className="card bg-base-100 shadow">
            <div className="card-body">
              <h3>Token X Balance</h3>
              <p className="text-2xl">{balanceX ?? 0}</p>
              <p className="text-xs text-gray-500">Mint: {TOKEN_X_MINT.toString()}</p>
            </div>
          </div>
          <div className="card bg-base-100 shadow">
            <div className="card-body">
              <h3>Token Y Balance</h3>
              <p className="text-2xl">{balanceY ?? 0}</p>
              <p className="text-xs text-gray-500">Mint: {TOKEN_Y_MINT.toString()}</p>
            </div>
          </div>
        </div>

        {/* Initialize Escrow */}
        <div className="card bg-base-100 shadow mb-4">
          <div className="card-body">
            <h2 className="card-title">Create New Swap</h2>
            <div className="form-control">
              <label className="label">
                <span className="label-text">Amount of JUP Tokens to Delegate</span>
              </label>
              <div className="flex items-center space-x-2">
                <input 
                  type="number"
                  min="0"
                  step="any"
                  value={swapAmount}
                  onChange={(e) => setSwapAmount(e.target.value)}
                  className="input input-bordered flex-1"
                  placeholder="Enter amount"
                />
                <span className="text-sm text-gray-500">JUP</span>
              </div>
              <label className="label">
                <span className="label-text-alt text-gray-500">
                  You will receive {swapAmount || '0'} GOV tokens in return
                </span>
              </label>
            </div>
            <div className="mt-4">
              <button 
                className="btn btn-primary w-full"
                onClick={handleInitializeEscrow}
                disabled={
                  !publicKey ||
                  !balanceY ||
                  isNaN(parseFloat(swapAmount)) ||
                  parseFloat(swapAmount) <= 0 ||
                  parseFloat(swapAmount) > (balanceY || 0)
                }
              >
                {!publicKey ? (
                  'Connect Wallet'
                ) : !balanceY ? (
                  'No JUP Balance'
                ) : parseFloat(swapAmount) > (balanceY || 0) ? (
                  'Insufficient JUP Balance'
                ) : (
                  `Delegate ${swapAmount || '0'} JUP to govAI - receive ${swapAmount || '0'} GOV`
                )}
              </button>
            </div>
          </div>
        </div>

      </div>
    </div>
  );
}
