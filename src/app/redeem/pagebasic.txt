'use client';

import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { useState, useEffect, useMemo } from 'react';
import {
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  Keypair
} from '@solana/web3.js';
import {
    TOKEN_PROGRAM_ID,
    AccountLayout,
    createInitializeAccountInstruction,
    createTransferInstruction,
    createAssociatedTokenAccountInstruction,
    getAssociatedTokenAddress,
    ASSOCIATED_TOKEN_PROGRAM_ID
  } from '@solana/spl-token';
import BN from 'bn.js';

import { TOKEN_X_MINT, TOKEN_Y_MINT, ESCROW_PROGRAM_ID } from '../../utils/constants';
import { notify } from '../components/ui/notify';
import { useGetTokenAccounts, useTokenBalance } from '@/hooks/use-token-accounts';
import { getEscrowAccount, Escrow, ESCROW_ACCOUNT_DATA_LAYOUT } from '@/utils/escrow';

/**
 * Converts a user-entered decimal string (e.g. "340.2") into a BN of raw lamports
 * given a token's decimal precision (e.g. 9 for many Solana tokens).
 */
function parseTokenAmountToBN(amountStr: string, decimals: number): BN {
  // Split on decimal point
  const [whole, fraction = ""] = amountStr.split('.');
  
  // Pad or slice the fraction part so it’s exactly `decimals` digits
  const fractionPart = fraction.padEnd(decimals, '0').slice(0, decimals);
  
  // Combine into an integer string, then parse as base 10
  const integerString = whole + fractionPart;
  return new BN(integerString, 10);
}

/**
 * Converts your "days → ratio" logic into a BN representing "ratio * 1e9".
 * Example: 
 *  - days = 0   => ratio = 0.7 => ratioBN = 700000000 
 *  - days = 30  => ratio = 1.0 => ratioBN = 1000000000
 */
function getRatioBN(days: number): BN {
  // ratio = 0.7 + 0.3*(days / 30)
  // We'll store ratio * 1e9 as an integer in BN.
  // => ratioBN = 700000000 + (300000000 * days / 30)

  const BASE = new BN('1000000000');         // 1e9
  const SEVENTY_PERCENT = new BN('700000000'); // 0.7 * 1e9
  const THIRTY_PERCENT = new BN('300000000'); // 0.3 * 1e9

  if (days >= 30) {
    // ratio = 1.0 => 1e9
    return BASE;
  }
  // Add fraction linearly (days * (0.3 * 1e9) / 30)
  const increment = THIRTY_PERCENT.mul(new BN(days)).div(new BN(30));
  return SEVENTY_PERCENT.add(increment);
}

function bnToDecimalString(amountBN: BN, decimals: number, maxFractionDigits = 4): string {
  // e.g. amountBN = 850000000, decimals=9 => "0.850000000"
  // then optionally trim to 4 decimal places => "0.85"
  
  // If amountBN < 10^(decimals), we need a leading zero.
  const baseStr = amountBN.toString().padStart(decimals+1, '0');
  const whole = baseStr.slice(0, -decimals) || "0";
  const fraction = baseStr.slice(-decimals).replace(/0+$/, ''); // optional trim
  let decimalStr = fraction.length > 0 ? `${whole}.${fraction}` : whole;
  
  // If you want only up to 4 decimals, do a further slice:
  if (fraction.length > maxFractionDigits) {
    decimalStr = `${whole}.${fraction.slice(0, maxFractionDigits)}`;
  }
  return decimalStr;
}


export default function UnstakePage() {
  const { connection } = useConnection();
  const { publicKey, signTransaction } = useWallet();
  const [isLoading, setIsLoading] = useState(false);
  const [unlockDays, setUnlockDays] = useState(30); // Default to 30 days
  const [govAmount, setGovAmount] = useState<string>("");

  // Get token accounts
  const { data: tokenAccounts, isLoading: isLoadingAccounts } = useGetTokenAccounts({
    address: publicKey,
  });

  // Find GOV and JUP token accounts
  const govTokenAccount = tokenAccounts?.find(
    (account) => account.account.data.parsed.info.mint === TOKEN_X_MINT.toString()
  );
  const jupTokenAccount = tokenAccounts?.find(
    (account) => account.account.data.parsed.info.mint === TOKEN_Y_MINT.toString()
  );

  // Get token balances
  const { data: balanceGOV } = useTokenBalance({
    tokenAccount: govTokenAccount ? new PublicKey(govTokenAccount.pubkey) : null,
  });
  const { data: balanceJUP } = useTokenBalance({
    tokenAccount: jupTokenAccount ? new PublicKey(jupTokenAccount.pubkey) : null,
  });

  // Calculate ratio based on unlock time
  const getRatio = (days: number): number => {
    if (days >= 30) return 1;
    // Linear ratio from 0.7 at 0 days to 1 at 30 days
    return 0.7 + (0.3 * days / 30);
  };

  // Instead of a floating pointer, do:
  const estimatedJUPReturn = useMemo(() => {
    if (!govAmount) return "0.0";
      const govBN = parseTokenAmountToBN(govAmount, 9);
      if (govBN.isZero()) return "0.0";
        const ratioBN = getRatioBN(unlockDays);
        // raw BN of JUP = govBN * ratio / 1e9
        const jupBN = govBN.mul(ratioBN).div(new BN('1000000000'));
        // Convert to a decimal string for display
        // If you want 4 decimal places, do:
        const decimals = 9;
        const jupStr = bnToDecimalString(jupBN, decimals, 4);
        return jupStr;
  }, [govAmount, unlockDays]);

  const handleInitializeUnstake = async () => {
    if (!publicKey || !signTransaction || !govTokenAccount) {
      notify({ type: 'error', message: 'Please connect your wallet and ensure you have a GOV token account' });
      return;
    }

    // Use BN parse. If user typed an empty or invalid string, parseTokenAmountToBN will give BN(0).
    const rawGovAmountBN = parseTokenAmountToBN(govAmount, 9); 
     if (rawGovAmountBN.lte(new BN(0))) {
      notify({ type: 'error', message: 'Invalid GOV amount' });
      return;
    }

    try {
      setIsLoading(true);

      // BN for ratio in "1e9" form
      const ratioBN = getRatioBN(unlockDays); 
      
      // rawGovAmountBN is "GOV in lamports" (already 1e9 scaled if decimals=9)
      // Multiply by ratioBN and divide by 1e9 to get "expected JUP in lamports"
      const expectedJUPAmountBN = rawGovAmountBN.mul(ratioBN).div(new BN('1000000000'));

      // Convert BN -> number for the actual instruction data
      // NOTE: This assumes the amounts fit in JS number range safely (< 2^53)
      const rawAmount = rawGovAmountBN.toNumber();
      const expectedJUPAmount = expectedJUPAmountBN.toNumber();

      const tempTokenAccountKeypair = Keypair.generate();
      const escrowAccountKeypair = Keypair.generate();

      // Calculate rent exemptions
      const rentExemptionTempToken = await connection.getMinimumBalanceForRentExemption(
        AccountLayout.span
      );
        const rentExemptionEscrow = await connection.getMinimumBalanceForRentExemption(
            ESCROW_ACCOUNT_DATA_LAYOUT.span
        );

      // Get or create JUP token account
      const jupATA = await getAssociatedTokenAddress(
        TOKEN_Y_MINT,
        publicKey,
        false,
        TOKEN_PROGRAM_ID,
        ASSOCIATED_TOKEN_PROGRAM_ID
      );

      console.log('Derived ATA:', jupATA.toString());
      console.log('Owner:', publicKey.toString());
      console.log('Mint:', TOKEN_X_MINT.toString());

      const instructions = [];

    
    if (!jupATA) {
        instructions.push(
        createAssociatedTokenAccountInstruction(
            publicKey,                // payer
            jupATA,   // ata
            publicKey,                // owner
            TOKEN_Y_MINT             // mint
        )
        );
    }

      instructions.push(
        SystemProgram.createAccount({
          fromPubkey: publicKey,
          newAccountPubkey: tempTokenAccountKeypair.publicKey,
          lamports: rentExemptionTempToken,
          space: AccountLayout.span,
          programId: TOKEN_PROGRAM_ID,
        })
      );

      instructions.push(
        createInitializeAccountInstruction(
          tempTokenAccountKeypair.publicKey,
          TOKEN_X_MINT,
          publicKey,
          TOKEN_PROGRAM_ID
        )
      );

      instructions.push(
        createTransferInstruction(
          new PublicKey(govTokenAccount.pubkey),
          tempTokenAccountKeypair.publicKey,
          publicKey,
          rawAmount,
          [],
          TOKEN_PROGRAM_ID
        )
      );

      instructions.push(
        SystemProgram.createAccount({
          fromPubkey: publicKey,
          newAccountPubkey: escrowAccountKeypair.publicKey,
          lamports: rentExemptionEscrow,
          space: ESCROW_ACCOUNT_DATA_LAYOUT.span,
          programId: ESCROW_PROGRAM_ID,
        })
      );

      console.log('Debug InitEscrow instruction:');
      console.log('Temp token account:', tempTokenAccountKeypair.publicKey.toString());
      console.log('Expected JUP amount (BN):', expectedJUPAmountBN.toString());
      console.log('GOV amount (BN):', rawGovAmountBN.toString());

      // Create the initialization instruction - matching working escrow pattern
      const initEscrowIx = new TransactionInstruction({
        programId: ESCROW_PROGRAM_ID,
        keys: [
          { pubkey: publicKey, isSigner: true, isWritable: false },         // initializer
          { pubkey: tempTokenAccountKeypair.publicKey, isSigner: false, isWritable: true },  // temp token account (GOV)
          { pubkey: jupATA, isSigner: false, isWritable: false },  // initializer's GOV account
          { pubkey: escrowAccountKeypair.publicKey, isSigner: false, isWritable: true },    // escrow state account
          { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
          { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        ],
        data: Buffer.from(
          Uint8Array.of(0, ...new BN(expectedJUPAmount).toArray("le", 8))
        ),
      });

      instructions.push(initEscrowIx);

      const transaction = new Transaction();
      instructions.forEach(ix => transaction.add(ix));
      
      transaction.feePayer = publicKey;
      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
      transaction.partialSign(tempTokenAccountKeypair, escrowAccountKeypair);

      const signedTx = await signTransaction(transaction);
      notify({ type: 'info', message: 'Please confirm the unstake initialization...' });
      
      const txId = await connection.sendRawTransaction(signedTx.serialize(), {
        skipPreflight: false,
        preflightCommitment: "confirmed"
      });
      
      notify({ type: 'info', message: 'Setting up your escrow...' });
      
      // Add better error handling for transaction confirmation
      const confirmation = await connection.confirmTransaction(txId, 'confirmed');
      if (confirmation.value.err) {
        const err = confirmation.value.err;
        throw new Error(`Transaction failed: ${JSON.stringify(err)}`);
      }
  
      notify({ 
        type: 'success', 
        message: `Unstake Escrow initialized!` 
      });
  
    } catch (error: any) {
      console.error('Initialize Escrow error:', error);
      // Check if it's a SendTransactionError
      if (error.logs) {
        console.error('Transaction logs:', error.logs);
      }
      notify({ type: 'error', message: `Failed to initialize escrow: ${error.message}` });
    }
  };

  return (
    <div className="container mx-auto p-8">
      <div className="grid gap-4">
        {/* Token Balances */}
        <div className="grid grid-cols-2 gap-4 mb-4">
          <div className="card bg-base-100 shadow">
            <div className="card-body">
              <h3>GOV Balance</h3>
              <p className="text-2xl">{balanceGOV ?? 0}</p>
              <p className="text-xs text-gray-500">Mint: {TOKEN_X_MINT.toString()}</p>
            </div>
          </div>
          <div className="card bg-base-100 shadow">
            <div className="card-body">
              <h3>JUP Balance</h3>
              <p className="text-2xl">{balanceJUP ?? 0}</p>
              <p className="text-xs text-gray-500">Mint: {TOKEN_Y_MINT.toString()}</p>
            </div>
          </div>
        </div>

        {/* Unstake Form */}
        <div className="card bg-base-100 shadow">
          <div className="card-body">
            <h2 className="card-title">Unstake GOV Tokens</h2>
            
            {/* Amount Input */}
            <div className="form-control">
              <label className="label">
                <span className="label-text">Amount of GOV to Unstake</span>
              </label>
              <input
                type="number"
                min="0"
                step="any"
                value={govAmount}
                onChange={(e) => setGovAmount(e.target.value)}
                className="input input-bordered w-full"
                placeholder="Enter amount"
              />
            </div>

            {/* Unlock Timer Slider */}
            <div className="form-control mt-4">
              <label className="label">
                <span className="label-text">Unlock Period: {unlockDays} days</span>
              </label>
              <input
                type="range"
                min="0"
                max="30"
                value={unlockDays}
                onChange={(e) => setUnlockDays(parseInt(e.target.value))}
                className="range"
                step="1"
              />
              <div className="flex justify-between text-xs px-2 mt-2">
                <span>Instant (30% fee)</span>
                <span>30 days (0% fee)</span>
              </div>
            </div>

            {/* Estimated Return */}
            <div className="mt-4 p-4 bg-base-200 rounded-lg">
              <h3 className="font-semibold mb-2">Estimated Return</h3>
              <p className="text-xl">{estimatedJUPReturn} JUP</p>
              <p className="text-sm text-gray-500">
                Rate: 1 GOV = {getRatio(unlockDays).toFixed(3)} JUP
              </p>
            </div>

            {/* Submit Button */}
            <button
              className="btn btn-primary w-full mt-4"
              onClick={handleInitializeUnstake}
              disabled={
                isLoading ||
                !publicKey ||
                !balanceGOV ||
                isNaN(parseFloat(govAmount)) ||
                parseFloat(govAmount) <= 0 ||
                parseFloat(govAmount) > (balanceGOV || 0)
              }
            >
              {isLoading ? (
                <span className="loading loading-spinner"></span>
              ) : !publicKey ? (
                'Connect Wallet'
              ) : !balanceGOV ? (
                'No GOV Balance'
              ) : parseFloat(govAmount) > (balanceGOV || 0) ? (
                'Insufficient GOV Balance'
              ) : (
                `Initialize Unstake`
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}